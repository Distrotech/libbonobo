/*
 * Canvas-based rendering of views
 *
 * Author:
 *    Miguel de Icaza (miguel@kernel.org)
 *
 * (C) 1999 International GNOME Support
 */

module GNOME {

module Gdk {
	/*
	 * Idea: would it make more sense to 
	 * not provide our own types and just copy
	 * the Gdk values instead of converting back and forth?
	 */
	enum EventType {
		FOCUS,
		KEY,
		MOTION,
		BUTTON,
		CROSSING
	};

	enum ButtonType {
		BUTTON_PRESS,
		BUTTON_2_PRESS,
		BUTTON_3_PRESS,
		BUTTON_RELEASE
	};

	enum KeyType {
		KEY_PRESS,
		KEY_RELEASE
	};

	enum CrossType {
		ENTER, LEAVE
	};

	enum CrossMode {
		NORMAL,
		GRAB,
		UNGRAB
	};

	typedef long Time;

	struct MotionEvent {
		Time   time;
		double x, y, x_root, y_root;
		double pressure;
		double xtilt, ytilt;
		long   state;
		boolean is_hint;
	};

	struct ButtonEvent {
		ButtonType type;
		Time       time;
		
		double x, y, x_root, y_root;

		short  button;
	};

	struct KeyEvent {
		KeyType type;
		Time    time;
		short	state;
		short	keyval;
		short	length;
		string  str;
	};

	struct CrossingEvent {
		CrossType    type;
		Time         time;
		double	     x, y, x_root, y_root;
		CrossMode    mode;
		boolean      focus;
		short        state;
	};

	struct FocusEvent {
		boolean      inside;
	};

	/*
	 * Only the lists of events supported by the Canvas
	 */
	union Event switch (EventType) {
		case FOCUS:    FocusEvent focus;
		case KEY:      KeyEvent key;
		case MOTION:   MotionEvent motion;
		case BUTTON:   ButtonEvent button;
		case CROSSING: CrossingEvent crossing;
	};
};

module Canvas {
	typedef sequence<octet> pixbuf;
	typedef unsigned long window_id;

	/* At least 32 bits */
	typedef long int32;

	struct IRect {
		long x0, y0, x1, y1;
	};

	struct DRect {
		double x0, y0, x1, y1;
	};

	const short IS_BG  = 1;
	const short IS_BUF = 2;

	typedef double affine [6];

	/*
	 * See gnome-canvas.h:GnomeCanvasBuf for an explanation
	 */
	struct Buf {
		pixbuf rgb_buf;
		long   row_stride;
		IRect  rect;
		int32  bg_color;
		short  flags;
	};

	struct Point {
		double x, y;
	};

	typedef sequence<Point> Points;

	struct SVPSegment {
		boolean up;     /* up or down */
	        DRect   bbox;
		Points  points;
	};
			  
	typedef sequence<SVPSegment> SVP;
      
	struct ArtUTA {
		short   x0, y0;
		short   width, height;
		sequence<int32> utiles;
	};

	interface Item : GNOME::Unknown {

		/** 
		 * update:
		 * 
		 * Returns the update region.
		 */
		ArtUTA update  (in affine aff, in SVP clip_path, in long flags,
				out double x1, out double y1, out double x2, out double y2);

		void realize ();
		void unrealize ();
		void map ();
		void unmap ();

		void draw   (in window_id drawable, in short x, in short y, in short width, in short height);

		/**
		 * render:
		 * @buf: The render control buffer.
		 * 
		 * This version of render has buf->flags & IS_BUF == FALSE, 
		 * so we avoid sending the buffer out, we just return it.
		 *
		 */
		void render (inout Buf buf);

		/**
		 * contains:
		 * @x: x coordinate 
		 * @y: y coordinate
		 *
		 * Returns true if the point at @x, @y is contained inside
		 * the item
		 */
		boolean contains (in double x, in double y);

		void bounds (out double x1, out double x2, out double y1, out double y2);

		boolean event (in GNOME::Gdk::Event event);

		/*
		 * Notifies this item about the size of the Canvas size on the 
		 * canvas
		 */
		void canvas_size_set (in short x, in short y, in short width, in short height);
	};

	/*
	 * This interface is used on the container side to forward
	 * events to the real containing canvas and the item
	 */
	
	interface ItemProxy {
		void request_update (in ArtUTA uta);
	};
};

};

